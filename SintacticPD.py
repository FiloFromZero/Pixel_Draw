"""
This module represents the behavior of a syntactic analyzer for PixelDraw.

The syntactic analyzer validates the structure of tokens generated by the lexical analyzer
and ensures they follow the correct grammar rules for the PixelDraw language.

Authors: Nicolás Alberto Rodríguez Delgado <20202020019>
         Daniel Mateo Montoya González <20202020098>
"""

# Grammar rules for PixelDraw language:
# <S>           -> <instruction>
# <instruction> -> <size> | <color> | <point> | <rectangle> | <repeat>
# <size>        -> "size"<space><integer>"x"<integer>
# <color>       -> "color"<space><COLORNAME> | "color"<space><COLORHEX>
# <point>       -> "point"<space><integer><space><integer>
# <rectangle>   -> "rectangle"<space><integer><space><integer><space><integer><space><integer>
# <repeat>      -> "repeat"<space><integer><space>"{" <instruction>* "}"
# <integer>     -> <digit>+
# <digit>       -> "0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"
# <COLORNAME>   -> <letters>+
# <COLORHEX>    -> "#"<DIGITHEX><DIGITHEX><DIGITHEX><DIGITHEX><DIGITHEX><DIGITHEX>
# <DIGITHEX>    -> <digit>|"A"..."F"|"a"..."f"
# <letters>     -> (a-zA-Z)+
# <space>       -> " "+

class SintacticAnalyzerPixelDraw:
    """
    Syntactic analyzer for PixelDraw language.
    
    This class validates that tokens from the lexical analyzer follow the correct
    grammar structure and provides error messages for syntax violations.
    """
    
    def __init__(self, tokens):
        """
        Initialize the syntactic analyzer with a list of tokens.
        
        Args:
            tokens (list): List of Token objects from the lexical analyzer
        """
        # Store the list of tokens to be parsed
        self.tokens = tokens
        # Initialize the current token
        self.current_token = None
        # Position in the token list
        self.pos = -1
        # Advance to the first token
        self.advance()

    def advance(self):
        """
        Move to the next token in the list.
        
        Updates the current_token and position. Sets current_token to None
        when all tokens have been processed.
        """
        # Move to the next token in the list
        self.pos += 1
        if self.pos < len(self.tokens):
            self.current_token = self.tokens[self.pos]
        else:
            # If there are no more tokens, set current_token to None
            self.current_token = None

    def parse(self):
        """
        Main parsing method that processes all instructions.
        
        Iterates through all tokens and validates each instruction according
        to the grammar rules. Stops when all tokens are processed.
        """
        # Main parsing loop: process instructions until tokens are exhausted
        while self.current_token is not None:
            self.instruccion()

    def instruccion(self):
        """
        Parse and validate a single instruction.
        
        Determines the type of instruction based on the current token and
        calls the appropriate parsing method. Raises syntax error for
        unrecognized instructions.
        """
        # Determine the type of instruction based on the current token
        if self.current_token is None:
            self.error("valid instruction")
        elif self.current_token.type_ == "SIZE":
            self.size()
        elif self.current_token.type_ == "COLOR":
            self.color()
        elif self.current_token.type_ == "POINT":
            self.point()
        elif self.current_token.type_ == "RECTANGLE":
            self.rectangle()
        elif self.current_token.type_ == "REPEAT_INI":
            self.repeat()
        else:
            # If the token does not match any known instruction, raise an error
            self.error("valid instruction")

    def size(self):
        """
        Parse and validate a SIZE instruction.
        
        Validates that the current token is a SIZE token and advances
        to the next token. Raises error if token type is incorrect.
        """
        # Handle the SIZE instruction
        if self.current_token is None:
            self.error("SIZE")
        elif self.current_token.type_ == "SIZE":
            print(f"Detected size: {self.current_token.value}")
            self.advance()
        else:
            self.error("SIZE")

    def color(self):
        """
        Parse and validate a COLOR instruction.
        
        Validates that the current token is a COLOR token and advances
        to the next token. Raises error if token type is incorrect.
        """
        # Handle the COLOR instruction
        if self.current_token is None:
            self.error("COLOR")
        elif self.current_token.type_ == "COLOR":
            print(f"Detected color: {self.current_token.value}")
            self.advance()
        else:
            self.error("COLOR")

    def point(self):
        """
        Parse and validate a POINT instruction.
        
        Validates that the current token is a POINT token and advances
        to the next token. Raises error if token type is incorrect.
        """
        # Handle the POINT instruction
        if self.current_token is None:
            self.error("POINT")
        elif self.current_token.type_ == "POINT":
            print(f"Detected point: {self.current_token.value}")
            self.advance()
        else:
            self.error("POINT")

    def rectangle(self):
        """
        Parse and validate a RECTANGLE instruction.
        
        Validates that the current token is a RECTANGLE token and advances
        to the next token. Raises error if token type is incorrect.
        """
        # Handle the RECTANGLE instruction
        if self.current_token is None:
            self.error("RECTANGLE")
        elif self.current_token.type_ == "RECTANGLE":
            print(f"Detected rectangle: {self.current_token.value}")
            self.advance()
        else:
            self.error("RECTANGLE")

    def repeat(self):
        """
        Parse and validate a REPEAT block.
        
        Validates the start of a repeat block, processes all instructions
        inside the block, and ensures proper closing with REPEAT_END.
        Raises error if block is not properly closed.
        """
        # Handle the REPEAT block
        if self.current_token is None:
            self.error("REPEAT_INI")
        elif self.current_token.type_ == "REPEAT_INI":
            print(f"Repeat start: {self.current_token.value}")
            self.advance()
            # Process instructions inside the repeat block
            while self.current_token is not None and self.current_token.type_ != "REPEAT_END":
                self.instruccion()
            # Check for the end of the repeat block
            if self.current_token and self.current_token.type_ == "REPEAT_END":
                print("Repeat end")
                self.advance()
            else:
                self.error("} (repeat block end)")
        else:
            self.error("REPEAT_INI")

    def error(self, expected):
        """
        Raise a syntax error with a descriptive message.
        
        Args:
            expected (str): Description of what was expected
            
        Raises:
            SyntaxError: With detailed error message including expected and found tokens
        """
        # Raise a syntax error with a descriptive message
        raise SyntaxError(f"Sintax error: expected {expected}, but found {self.current_token}")
